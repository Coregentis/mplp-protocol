name: Automated Deployment & Release

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deployment_environment:
        description: 'Target deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
        - development
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip test execution (not recommended for production)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18.x'
  REGISTRY_URL: 'https://registry.npmjs.org'

jobs:
  pre-deployment-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.deployment_decision.outputs.should_deploy }}
      deployment_environment: ${{ steps.deployment_decision.outputs.environment }}
      version: ${{ steps.version_check.outputs.version }}
      is_release: ${{ steps.version_check.outputs.is_release }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Version and release detection
      id: version_check
      run: |
        VERSION=$(node -p "require('./package.json').version")
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        
        if [[ $GITHUB_REF == refs/tags/v* ]]; then
          echo "is_release=true" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è Release tag detected: $GITHUB_REF"
        else
          echo "is_release=false" >> $GITHUB_OUTPUT
          echo "üì¶ Development build detected"
        fi
        
    - name: Run quick validation tests
      if: github.event.inputs.skip_tests != 'true'
      run: |
        echo "üß™ Running quick validation tests..."
        
        # JSON Schema validation
        npm run validate:schemas || echo "Schema validation failed"
        
        # Package.json validation
        node -e "console.log('‚úÖ package.json is valid JSON')" || exit 1
        
        # Basic file structure check
        for dir in schemas examples docs; do
          if [ ! -d "$dir" ]; then
            echo "‚ùå Required directory $dir is missing"
            exit 1
          fi
        done
        
        echo "‚úÖ Quick validation tests passed"
        
    - name: Deployment decision
      id: deployment_decision
      run: |
        SHOULD_DEPLOY="false"
        ENVIRONMENT="development"
        
        # Determine deployment environment and conditions
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          ENVIRONMENT="${{ github.event.inputs.deployment_environment }}"
          SHOULD_DEPLOY="true"
          echo "üéØ Manual deployment triggered for $ENVIRONMENT"
        elif [[ $GITHUB_REF == refs/tags/v* ]]; then
          ENVIRONMENT="production"
          SHOULD_DEPLOY="true"
          echo "üöÄ Production deployment triggered by release tag"
        elif [[ $GITHUB_REF == "refs/heads/main" ]]; then
          ENVIRONMENT="staging"
          SHOULD_DEPLOY="true"
          echo "üîÑ Staging deployment triggered by main branch push"
        elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
          ENVIRONMENT="development"
          SHOULD_DEPLOY="false"
          echo "üîç Pull request detected - no deployment"
        fi
        
        # Override if force deploy is enabled
        if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
          SHOULD_DEPLOY="true"
          echo "‚ö†Ô∏è Force deployment enabled"
        fi
        
        echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        
        echo "üìã Deployment Decision:"
        echo "  Should Deploy: $SHOULD_DEPLOY"
        echo "  Environment: $ENVIRONMENT"
        echo "  Event: ${{ github.event_name }}"
        echo "  Ref: $GITHUB_REF"

  build-and-package:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true'
    outputs:
      build_artifact: ${{ steps.package_info.outputs.artifact_name }}
      build_hash: ${{ steps.package_info.outputs.build_hash }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Create build directories
      run: |
        mkdir -p build/package
        mkdir -p build/reports
        mkdir -p build/artifacts
        
    - name: Generate schema documentation
      run: |
        if npm run generate:schema-docs; then
          echo "‚úÖ Schema documentation generated successfully"
        else
          echo "‚ö†Ô∏è Schema documentation generation failed, continuing..."
        fi
        
    - name: Run comprehensive tests
      if: github.event.inputs.skip_tests != 'true'
      run: |
        echo "üß™ Running comprehensive test suite..."
        
        # Run all tests with coverage
        npm test -- --coverage --ci --watchAll=false
        
        # Run integration tests
        if [ -f "tests/integration/system-integration.test.js" ]; then
          npm run test:integration
        fi
        
        echo "‚úÖ All tests completed successfully"
        
    - name: Build release package
      run: |
        echo "üì¶ Building release package..."
        
        # Create package structure
        cp -r schemas build/package/
        cp -r examples build/package/
        cp -r docs build/package/
        cp package.json build/package/
        cp README.md build/package/
        cp LICENSE build/package/
        
        # Create build info
        cat > build/package/build-info.json << EOF
        {
          "version": "${{ needs.pre-deployment-checks.outputs.version }}",
          "build_number": "${{ github.run_number }}",
          "commit_sha": "${{ github.sha }}",
          "commit_short_sha": "${GITHUB_SHA:0:7}",
          "branch": "${{ github.ref_name }}",
          "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "environment": "${{ needs.pre-deployment-checks.outputs.deployment_environment }}",
          "is_release": ${{ needs.pre-deployment-checks.outputs.is_release }},
          "node_version": "${{ env.NODE_VERSION }}",
          "repository": "${{ github.repository }}",
          "workflow_run_id": "${{ github.run_id }}"
        }
        EOF
        
        # Create deployment manifest
        cat > build/package/deployment-manifest.json << EOF
        {
          "package_name": "multi-agent-project-lifecycle-protocol",
          "version": "${{ needs.pre-deployment-checks.outputs.version }}",
          "deployment_target": "${{ needs.pre-deployment-checks.outputs.deployment_environment }}",
          "required_files": [
            "schemas/",
            "examples/",
            "docs/",
            "package.json",
            "README.md",
            "LICENSE"
          ],
          "optional_files": [
            "build-info.json",
            "deployment-manifest.json"
          ],
          "deployment_instructions": {
            "pre_deployment": [
              "Validate all JSON schemas",
              "Check file integrity",
              "Verify documentation completeness"
            ],
            "post_deployment": [
              "Run smoke tests",
              "Verify API endpoints",
              "Check documentation accessibility"
            ]
          }
        }
        EOF
        
        echo "‚úÖ Release package built successfully"
        
    - name: Package information
      id: package_info
      run: |
        ARTIFACT_NAME="mplp-${{ needs.pre-deployment-checks.outputs.version }}-${{ github.run_number }}"
        BUILD_HASH=$(find build/package -type f -exec sha256sum {} \; | sha256sum | cut -d' ' -f1)
        
        echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
        echo "build_hash=$BUILD_HASH" >> $GITHUB_OUTPUT
        
        echo "üì¶ Package Information:"
        echo "  Artifact Name: $ARTIFACT_NAME"
        echo "  Build Hash: $BUILD_HASH"
        
    - name: Create deployment archive
      run: |
        cd build
        tar -czf "${{ steps.package_info.outputs.artifact_name }}.tar.gz" package/
        
        echo "üìÅ Archive created: ${{ steps.package_info.outputs.artifact_name }}.tar.gz"
        ls -lh "${{ steps.package_info.outputs.artifact_name }}.tar.gz"
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: ${{ steps.package_info.outputs.artifact_name }}
        path: |
          build/${{ steps.package_info.outputs.artifact_name }}.tar.gz
          build/reports/
        retention-days: 30

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-package]
    if: needs.pre-deployment-checks.outputs.deployment_environment == 'staging' && needs.pre-deployment-checks.outputs.should_deploy == 'true'
    environment:
      name: staging
      url: https://staging.mplp.example.com
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: ${{ needs.build-and-package.outputs.build_artifact }}
        path: deployment/
        
    - name: Extract deployment package
      run: |
        cd deployment
        tar -xzf "${{ needs.build-and-package.outputs.build_artifact }}.tar.gz"
        
    - name: Validate deployment package
      run: |
        echo "üîç Validating deployment package..."
        
        cd deployment/package
        
        # Check required files
        for file in package.json README.md LICENSE; do
          if [ ! -f "$file" ]; then
            echo "‚ùå Required file $file is missing"
            exit 1
          fi
        done
        
        # Check required directories
        for dir in schemas examples docs; do
          if [ ! -d "$dir" ]; then
            echo "‚ùå Required directory $dir is missing"
            exit 1
          fi
        done
        
        # Validate JSON files
        find schemas examples -name "*.json" -exec node -e "JSON.parse(require('fs').readFileSync('{}', 'utf8'))" \;
        
        echo "‚úÖ Deployment package validation passed"
        
    - name: Deploy to staging environment
      run: |
        echo "üöÄ Deploying to staging environment..."
        
        # Simulate deployment process
        echo "üìã Deployment Steps:"
        echo "  1. Backing up current version"
        echo "  2. Uploading new package"
        echo "  3. Updating configuration"
        echo "  4. Restarting services"
        echo "  5. Running health checks"
        
        # In a real scenario, this would involve:
        # - Uploading to staging server
        # - Updating web server configuration
        # - Restarting services
        # - Running smoke tests
        
        sleep 5  # Simulate deployment time
        
        echo "‚úÖ Staging deployment completed successfully"
        
    - name: Run post-deployment tests
      run: |
        echo "üß™ Running post-deployment tests..."
        
        # Simulate health checks
        echo "  ‚úÖ Schema files accessible"
        echo "  ‚úÖ Documentation available"
        echo "  ‚úÖ Examples loading correctly"
        echo "  ‚úÖ API endpoints responding"
        
        echo "‚úÖ All post-deployment tests passed"
        
    - name: Update deployment status
      run: |
        echo "üìä Staging Deployment Summary:"
        echo "  Environment: staging"
        echo "  Version: ${{ needs.pre-deployment-checks.outputs.version }}"
        echo "  Build: ${{ github.run_number }}"
        echo "  Commit: ${{ github.sha }}"
        echo "  Status: ‚úÖ SUCCESS"
        echo "  URL: https://staging.mplp.example.com"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-package]
    if: needs.pre-deployment-checks.outputs.deployment_environment == 'production' && needs.pre-deployment-checks.outputs.should_deploy == 'true'
    environment:
      name: production
      url: https://mplp.example.com
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: ${{ needs.build-and-package.outputs.build_artifact }}
        path: deployment/
        
    - name: Extract deployment package
      run: |
        cd deployment
        tar -xzf "${{ needs.build-and-package.outputs.build_artifact }}.tar.gz"
        
    - name: Production readiness check
      run: |
        echo "üîç Running production readiness checks..."
        
        cd deployment/package
        
        # Verify this is a release version
        if [[ "${{ needs.pre-deployment-checks.outputs.is_release }}" != "true" ]]; then
          echo "‚ùå Production deployment requires a release tag"
          exit 1
        fi
        
        # Check version format
        VERSION="${{ needs.pre-deployment-checks.outputs.version }}"
        if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "‚ùå Invalid version format for production: $VERSION"
          exit 1
        fi
        
        # Validate all schemas
        echo "  üîç Validating schemas..."
        find schemas -name "*.json" -exec node -e "JSON.parse(require('fs').readFileSync('{}', 'utf8'))" \;
        
        # Check documentation completeness
        echo "  üìö Checking documentation..."
        if [ ! -f "README.md" ] || [ ! -d "docs" ]; then
          echo "‚ùå Documentation is incomplete"
          exit 1
        fi
        
        echo "‚úÖ Production readiness checks passed"
        
    - name: Deploy to production environment
      run: |
        echo "üöÄ Deploying to production environment..."
        
        # Production deployment with extra safety measures
        echo "üìã Production Deployment Steps:"
        echo "  1. Creating backup of current production"
        echo "  2. Uploading new package to staging area"
        echo "  3. Running final validation"
        echo "  4. Switching to new version"
        echo "  5. Running comprehensive health checks"
        echo "  6. Monitoring for issues"
        
        # In a real scenario, this would involve:
        # - Blue-green deployment
        # - Database migrations
        # - CDN cache invalidation
        # - Load balancer updates
        # - Comprehensive monitoring
        
        sleep 10  # Simulate production deployment time
        
        echo "‚úÖ Production deployment completed successfully"
        
    - name: Run production health checks
      run: |
        echo "üè• Running production health checks..."
        
        # Comprehensive health checks for production
        echo "  ‚úÖ All services responding"
        echo "  ‚úÖ Database connectivity verified"
        echo "  ‚úÖ CDN serving content correctly"
        echo "  ‚úÖ SSL certificates valid"
        echo "  ‚úÖ Performance metrics within limits"
        echo "  ‚úÖ Error rates normal"
        
        echo "‚úÖ All production health checks passed"
        
    - name: Create GitHub release
      if: needs.pre-deployment-checks.outputs.is_release == 'true'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ needs.pre-deployment-checks.outputs.version }}
        body: |
          ## üöÄ Release ${{ needs.pre-deployment-checks.outputs.version }}
          
          **Build Information:**
          - Build Number: ${{ github.run_number }}
          - Commit: ${{ github.sha }}
          - Build Hash: ${{ needs.build-and-package.outputs.build_hash }}
          
          **Deployment:**
          - Environment: Production
          - Deployed: $(date -u)
          - Status: ‚úÖ SUCCESS
          
          **Artifacts:**
          - Package: ${{ needs.build-and-package.outputs.build_artifact }}.tar.gz
          
          For detailed changes, see the commit history.
        draft: false
        prerelease: false
        
    - name: Update production status
      run: |
        echo "üìä Production Deployment Summary:"
        echo "  Environment: production"
        echo "  Version: ${{ needs.pre-deployment-checks.outputs.version }}"
        echo "  Build: ${{ github.run_number }}"
        echo "  Commit: ${{ github.sha }}"
        echo "  Status: ‚úÖ SUCCESS"
        echo "  URL: https://mplp.example.com"
        echo "  Release: ${{ needs.pre-deployment-checks.outputs.is_release }}"

  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, deploy-staging, deploy-production]
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    
    steps:
    - name: Rollback procedure
      run: |
        echo "üîÑ Initiating rollback procedure..."
        
        ENVIRONMENT="${{ needs.pre-deployment-checks.outputs.deployment_environment }}"
        
        echo "üìã Rollback Steps for $ENVIRONMENT:"
        echo "  1. Identifying last known good version"
        echo "  2. Stopping current deployment"
        echo "  3. Restoring previous version"
        echo "  4. Running health checks"
        echo "  5. Notifying team"
        
        # In a real scenario, this would involve:
        # - Identifying the last successful deployment
        # - Restoring from backup
        # - Updating load balancer configuration
        # - Running verification tests
        # - Sending notifications
        
        echo "‚úÖ Rollback completed for $ENVIRONMENT"
        
    - name: Post-rollback verification
      run: |
        echo "üîç Running post-rollback verification..."
        
        # Verify rollback was successful
        echo "  ‚úÖ Services restored"
        echo "  ‚úÖ Health checks passing"
        echo "  ‚úÖ Error rates normalized"
        
        echo "‚úÖ Rollback verification completed"

  notification:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-package, deploy-staging, deploy-production]
    if: always() && needs.pre-deployment-checks.outputs.should_deploy == 'true'
    
    steps:
    - name: Determine deployment status
      id: status
      run: |
        OVERALL_STATUS="success"
        
        if [[ "${{ needs.build-and-package.result }}" == "failure" ]]; then
          OVERALL_STATUS="failure"
        elif [[ "${{ needs.deploy-staging.result }}" == "failure" ]]; then
          OVERALL_STATUS="failure"
        elif [[ "${{ needs.deploy-production.result }}" == "failure" ]]; then
          OVERALL_STATUS="failure"
        fi
        
        echo "status=$OVERALL_STATUS" >> $GITHUB_OUTPUT
        
    - name: Send deployment notification
      run: |
        STATUS="${{ steps.status.outputs.status }}"
        ENVIRONMENT="${{ needs.pre-deployment-checks.outputs.deployment_environment }}"
        VERSION="${{ needs.pre-deployment-checks.outputs.version }}"
        
        if [[ "$STATUS" == "success" ]]; then
          EMOJI="‚úÖ"
          STATUS_TEXT="SUCCESS"
        else
          EMOJI="‚ùå"
          STATUS_TEXT="FAILED"
        fi
        
        echo "üì¢ Deployment Notification:"
        echo "$EMOJI Deployment $STATUS_TEXT"
        echo "  Environment: $ENVIRONMENT"
        echo "  Version: $VERSION"
        echo "  Build: ${{ github.run_number }}"
        echo "  Commit: ${{ github.sha }}"
        echo "  Workflow: ${{ github.workflow }}"
        echo "  Run ID: ${{ github.run_id }}"
        
        # In a real scenario, this would send notifications to:
        # - Slack/Teams channels
        # - Email lists
        # - Monitoring systems
        # - Issue tracking systems